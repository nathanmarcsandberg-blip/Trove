<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>trove assets</title>

  <!-- keep your site stylesheet -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <main class="assets-wrap">
    <h1 style="text-align:center;margin:24px 0">trove assets</h1>

    <!-- toolbar -->
    <div class="asset-toolbar">
      <input id="assetSearch" class="asset-search" placeholder="Search assets…" />
      <button class="pill active" data-cat="all">All</button>
      <button class="pill" data-cat="dividend_paying_stock">Dividend Stock</button>
      <button class="pill" data-cat="non_dividend_paying_stock">Non-Dividend Stock</button>
      <button class="pill" data-cat="cryptocurrency">Crypto</button>
    </div>

    <!-- status + action -->
    <div class="asset-toolbar" style="justify-content:flex-start">
      <span id="pricesUpdatedTag" class="price-tag">Prices Last Updated: —</span>
      <button id="updateRatesBtn" class="btn">Update Rates</button>
    </div>

    <!-- list -->
    <div id="assetsList" class="grid"></div>
  </main>

  <!-- DATA LAYERS (load exactly these two if you're using the config+prices setup) -->
  <script src="assets-config.js" defer></script>
  <script src="data-prices.js" defer></script>
  <!-- OR: if you’re using the single-file app, just include assets-app.js instead -->
  <!-- <script src="assets-app.js" defer></script> -->

  <script>
    // -------- renderer (uses window.ASSET_LIST) --------
    document.addEventListener('DOMContentLoaded', () => {
      const listEl   = document.getElementById('assetsList');
      const tagEl    = document.getElementById('pricesUpdatedTag');
      const btnEl    = document.getElementById('updateRatesBtn');
      const searchEl = document.getElementById('assetSearch');
      const pills    = Array.from(document.querySelectorAll('.pill'));

      let currentCat = 'all';
      let q = '';

      function rows() {
        // Prefer live list if provided; otherwise build from FIXED_ASSETS for first paint
        if (Array.isArray(window.ASSET_LIST)) return window.ASSET_LIST;
        if (Array.isArray(window.FIXED_ASSETS)) {
          return window.FIXED_ASSETS.map(a => ({ name: a.name, class: a.class, price: 0, yield: '' }));
        }
        return [];
      }

      function render() {
        const data = rows();
        const filtered = data.filter(r =>
          (currentCat === 'all' || r.class === currentCat) &&
          (!q || r.name.toLowerCase().includes(q))
        );

        const html = filtered.map(r => {
          const priceStr = Number.isFinite(r.price) && r.price > 0 ? `$${(+r.price).toFixed(2)}` : '—';
          const y = (r.yield && r.yield !== '0' && r.yield !== '0%') ? ` <span class="yield" style="color:#0a8a2a">${r.yield}</span>` : '';
          const niceClass = (r.class || '').replaceAll('_', ' ');
          return `
            <div class="asset-card">
              <div class="asset-header"><a class="asset-name">${r.name}</a></div>
              <div class="asset-price" style="font-weight:600">${priceStr}${y ? ' – ' + y : ''}</div>
              <div class="asset-meta">${niceClass}</div>
            </div>
          `;
        }).join('');
        listEl.innerHTML = html;
      }

      // search + filters
      searchEl.addEventListener('input', e => { q = e.target.value.trim().toLowerCase(); render(); });
      pills.forEach(p => p.addEventListener('click', () => {
        pills.forEach(x => x.classList.remove('active'));
        p.classList.add('active');
        currentCat = p.dataset.cat || 'all';
        render();
      }));

      // last-updated tag (supports either data layer naming)
      function getUpdatedTag() {
        if (window.TroveData?.getLastUpdatedTag) return window.TroveData.getLastUpdatedTag();
        if (window.TrovePricing?.fmtTag) {
          const iso = localStorage.getItem('trove_prices_last_updated_v1') || localStorage.getItem('trove_prices_last_updated_v2');
          return window.TrovePricing.fmtTag(iso);
        }
        const iso = localStorage.getItem('trove_prices_last_updated_v1') || localStorage.getItem('trove_prices_last_updated_v2');
        if (!iso) return '—';
        const d = new Date(iso);
        const pad = n => String(n).padStart(2,'0');
        return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      }

      // hook into data-layer change callbacks if present
      if (window.TroveData?.onChange) {
        window.TroveData.onChange(() => { tagEl.textContent = 'Prices Last Updated: ' + getUpdatedTag(); render(); });
      }

      // update button works with either data layer
      btnEl.addEventListener('click', async () => {
        btnEl.disabled = true; const prev = btnEl.textContent; btnEl.textContent = 'Updating…';
        try {
          if (window.TrovePricing?.refreshPrices)      await window.TrovePricing.refreshPrices();
          else if (window.TroveData?.refreshPrices)    await window.TroveData.refreshPrices(true);
        } catch (e) {
          console.error('Update failed', e);
          alert('Update failed (see console).');
        } finally {
          tagEl.textContent = 'Prices Last Updated: ' + getUpdatedTag();
          render();
          btnEl.disabled = false; btnEl.textContent = prev;
        }
      });

      // first paint + attempt auto refresh if available
      tagEl.textContent = 'Prices Last Updated: ' + getUpdatedTag();
      render();
      (async () => {
        try {
          if (window.TrovePricing?.refreshPrices)      await window.TrovePricing.refreshPrices();
          else if (window.TroveData?.refreshPrices)    await window.TroveData.refreshPrices(false);
          tagEl.textContent = 'Prices Last Updated: ' + getUpdatedTag();
          render();
        } catch(e) { /* ignore */ }
      })();
    });
  </script>
</body>
</html>
